\documentclass{article}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage[noend]{algorithmic}
\usepackage{subfigure}
\usepackage{amssymb, amsmath, graphicx, charter, latexsym}
\usepackage{layouts}
\usepackage[letterpaper]{geometry}
\usepackage{enumerate}
\usepackage{epstopdf}
\usepackage{ragged2e}
%\usepackage{times}
\usepackage{mathtools}
%\usepackage[scaled]{helvet}
\usepackage{mathptmx}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{siunitx}
\usepackage{booktabs}

\lstset{
basicstyle=\ttfamily,
}

\begin{document}

\title{\bf ECEN 689-- Real-Time Wireless Networks: Project 2\\ (Due on 4/1)}
\date{}
\author{%
Ping-Chun Hsieh\\
\texttt{lleyfede@tamu.edu}
\and
Tao Zhao\\
\texttt{alick@tamu.edu}
\and
Dongni Han\\
\texttt{handongni2015@tamu.edu}
}
\maketitle

\section*{Terminology}

In our report, we use ``server'' to denote the WiFi access point (AP), and
``client'' to denote the terminal device such as a mobile phone, a tablet, and
so on. Throughout our simulation, we let node $0$ be the server, and node $1$ be
the client, which correspond to the device A and B in the problem descriptions
respectively.

S-WiFi is the name of our application as well as our project. It stands for
Smart WiFi, or whatever you think it is.

\section*{Simulation Setup}
\begin{table}[htbp]
\centering
    \caption{Parameters of the wireless channel.}
    \vspace{2mm}
    \begin{tabular}{ | l | l | }
    \hline
    Item & Value \\ \hline
    Path loss exponent & 2.0  \\ \hline
    Shadowing deviation & \SI{4.0}{dB} \\ \hline
    Reference distance & \SI{1.0}{m} \\
    \hline
\end{tabular}
\label{table: channel}
\end{table}
Throughout the report, we consider a single wireless link between two devices, say A and B. The transmitter power level is \SI{10}{mW}. We use the shadowing module as the wireless channel. The parameters of the channel are summarized in Table \ref{table: channel}.

\begin{table}[htbp]
\centering
\caption{Parameters of the 802.11b MAC.}
    \vspace{2mm}
    \begin{tabular}{ | l | l | }
    \hline
    Item & Value \\ \hline
    Data rate & \SI{11}{Mb/s}  \\ \hline
    Basic rate & \SI{1}{Mb/s}  \\ \hline
    PLCP data rate & \SI{1}{Mb/s}  \\ \hline 
    Preamble length & \SI{144}{bits} \\ \hline
    Slot time & \SI{20}{\mu s} \\ \hline
    SIFS & \SI{10}{\mu s} \\
    \hline
\end{tabular}
\label{table: mac}
\end{table}

For the medium access control (MAC) layer, we use the 802.11 module built in ns-2. Following the IEEE 802.11b standard, the MAC layer parameters are chosen as in Table \ref{table: mac}.


\section*{Uplink Transmissions with PCF}
\label{section: uplink}



\section{Baseline Policy}
\label{section: baseline}


\frenchspacing In PCF mode, the AP decides which client can transmit: The AP will first send a POLL packet to the selected client. A client can only transmit its packet after it receives the POLL packet from the AP. This allows the AP to have full control over which client transmits. 

Baseline policy: At the beginning of each interval, the AP asks each client, one by one, the number of packets that it generates. After this process, the AP also knows the number of packets at each client, and it can make the best decision.

First of all, the server can poll packets or poll data implemented by function \lstinline |command| in the swifi.cc file. Then, the client enables to send number of packets or data to the server implemented by function \lstinline |recv| in the swifi.cc file. Also, we need function \lstinline |scheduleRoundRobin| to let AP ask each client one by one the number of packets that it generates at the beginning of each interval. Then, we need function \lstinline |scheduleMaxWeight| to implement maxweight policy. 

Besides, we define four data types. 
\begin{table}[h!]
   \centering
   \caption{Data Type}
   \label{tab:table3}
   \begin{tabular}{| l | l |}
      \hline
      Data Type  &  Meaning\\ \hline
      \lstinline |SWiFi_POLL_NUM| & Poll number of packets in uplink\\ \hline 
      \lstinline |SWiFi_PKT_POLL_DATA|  & Poll data packet transmission in uplink\\ \hline 
      \lstinline |SWiFi_PKT_NUM_UL| & Packet in uplink that carries number of packets at client\\ \hline 
      \lstinline |SWiFi_PKT_DATA_UL| & Data packet in uplink(client to server)\\  
     \hline
   \end{tabular}
\end{table}
 
What's more, four poll states are defined below. 
\begin{table}[h!]
   \centering
   \caption{Poll State}
   \label{tab:table4}
   \begin{tabular}{| l | l |}
      \hline
      Poll State  &  Meaning\\ \hline
      \lstinline |SWiFi_POLL_NONE| & Poll nothing\\ \hline 
      \lstinline |SWiFi_POLL_NUM|  & Poll num of packets\\ \hline 
      \lstinline |SWiFi_POLL_DATA| & Poll data\\ \hline 
      \lstinline |SWiFi_POLL_IDLE| & Idle\\  
     \hline
   \end{tabular}
\end{table}
     

\section{Implementation in NS-2}
\label{section: ns2}
In our SWiFi project, the way we implement baseline policy is described as follows. 

In the \lstinline |command| function in swifi.cc

When the system captures a string called  \lstinline |server| indicating that it is a server(AP). If the value of  \lstinline |do_pull_num|  is true,  \lstinline |poll_state_|  will be set to  \lstinline |SWiFi_POLL_NUM|. Otherwise, when the value of  \lstinline |do_pull_num|  is false,   \lstinline |poll_state_|  will be set  \lstinline |SWiFi_POLL_DATA|. 


When the system captures a string called  \lstinline |poll|, tcl will print an error: only server AP can poll if it's not a server. If it's a server, the server(AP) will ask each client one by one using function \lstinline |scheduleRoundRobin| when the \lstinline |poll_state_| is  \lstinline |SWiFi_POLL_NUM|. And we set the packet type to \lstinline |SWiFi_PKT_POLL_NUM|, store current time and send the new packet. Otherwise, the server(AP) will use maxweight policy to schedule clients using function \lstinline |scheduleMaxWeight| when the \lstinline |poll_state_| is  \lstinline |SWiFi_POLL_DATA|. And we set the packet type to \lstinline |SWiFi_PKT_POLL_DATA|, store current time and send the new packet. Besides, there is one special condition that no more client is left in one interval (\lstinline |target_| is true). In this case, \lstinline |poll_state_| will be set to \lstinline |SWiFi_POLL_IDLE|.


When the system captures a string \lstinline |boi|, the system will set \lstinline |target_| to NULL. If  \lstinline |realtime_|  is true indicating it is real-time traffic, we need clear number of data packets of all clients at the beginning of each interval. 

In the  \lstinline |recv| function in swifi.cc

When a client receives a packet type \lstinline |SWiFi_PKT_POLL_DATA| transmitted by a server, we save the old packet's send time, discard the old packet, create a new packet, set new send time and send this new packet to the server(AP). 
When a client receives a packet type \lstinline |SWiFi_PKT_POLL_NUM| transmitted by a server, we set the data type to \lstinline |SWiFi_PKT_NUM_UL| meaning that it is uplink packet with numbers of packets at client, set new send time and send this new packet to the server(AP).
When a server receivers  a packet type \lstinline |SWiFi_PKT_NUM_UL| transmitted by a client, the current queue length is equal to the number of data packets generated minus the number of data packets received. For real-time traffic, the current queue length is equal to the number of data packets generated.  

For Real-time traffic: At the beginning of each interval, we need clean queues of all clients cause we don't need store the queue length last interval. The current queue length just equals random number of packets at the beginning of each interval. 

For Non-real-time traffic: We need store the queue length last interval. The current queue length is equal to the number of data packets generated minus the number of data packets received. 

\section{Simulation Results}
\label{section: simulation}
\subsection{Symmetric System with 2 Clients}
Under the simulation setup described above, the real-time 
Real-time and non-real-time traffic
\subsection{Asymmetric System with 2 Clients}

\subsection{System with N Clients}
%\begin{figure}[htbp]
%\centering
%\subfigure[Downlink round-trip time.]{
%\includegraphics[scale = 0.7]{downlink_rtt.pdf}}
%\subfigure[Uplink round-trip time.]{
%\includegraphics[scale = 0.7]{uplink_rtt.pdf}}
%\caption{Round-trip time when node A and node B are close to each other.}
%\label{figure: rtt}
%\end{figure}


\end{document}